[
    {
        "question_number": 1,
        "question_content": "Fine-grained trong dịch vụ web có đặc điểm gì?",
        "options": {
            "A": "Cung cấp các dịch vụ có phạm vi rộng",
            "B": "Cung cấp các dịch vụ lớn, tổng quát",
            "C": "Cung cấp các dịch vụ tương đối nhỏ và phổ biến",
            "D": "Cung cấp các dịch vụ nhỏ, chi tiết"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 2,
        "question_content": "Thời gian chờ phản hồi khi yêu cầu dịch vụ web phức tạp ?",
        "options": {
            "A": "Thời gian chờ phải hồi lâu",
            "B": "Thời gian chờ phải hồi nhanh",
            "C": "Thời gian chờ phản hồi phụ thuộc vào độ phức tạp dịch vụ",
            "D": "Không có thời gian chờ phản hồi"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 3,
        "question_content": "Một giao diện dịch vụ có thể có bao nhiêu thực thi dịch vụ",
        "options": {
            "A": "Mỗi giao diện dịch vụ chỉ được phép có duy nhất 1 thực thi",
            "B": "Số lượng giao diện dịch vụ không vượt quá số lượng giao thức triển khai",
            "C": "Số lượng giao diện dịch vụ không vượt quá số lượng endpoint triển khai",
            "D": "Mỗi giao diện có thể có nhiều thực thi"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 4,
        "question_content": "Điều kiện để một dịch vụ được coi là bất khả tri?",
        "options": {
            "A": "Chứa logic có khả năng tái sử dụng bởi nhiều quy trình kinh doanh",
            "B": "Chứa logic được sử dụng trong một quy trình kinh doanh duy nhất",
            "C": "Các chức năng được phát triển từ các thực thể",
            "D": "Các chức năng chỉ gồm logic không liên quan đến thực thể"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 5,
        "question_content": "Các giai đoạn đầu tiên khi phân tích kho dịch vụ là gì?",
        "options": {
            "A": "Define Technology Architecture",
            "B": "Define Enterprise Business Models",
            "C": "Perform Service-Oriented Analysis",
            "D": "Define Service Inventory Blueprint"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 6,
        "question_content": "Mục đích của quá trình mô hình hóa dịch vụ là gì?",
        "options": {
            "A": "Tổ chức các đơn vị logic thành các giải pháp hướng dịch vụ",
            "B": "Phân loại các đơn vị logic dựa trên kích thước của chúng",
            "C": "Tạo nhãn cho các lớp hướng dịch vụ",
            "D": "Xác định bản chất của các đơn vị logic"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 7,
        "question_content": "Trong phân tích hướng dịch vụ, các agnostic logic trong quy trình kinh doanh là những logic như thế nào?",
        "options": {
            "A": "Có khả năng tái sử dụng lại cao trong nhiều quy trình nghiệp vụ",
            "B": "Chỉ phục vụ một quy trình nghiệp vụ cụ thể và không thể tái sử dụng trong các quy trình khác",
            "C": "Liên quan đến việc xử lý dữ liệu của các hệ thống cụ thể mà không phụ thuộc vào ngữ cảnh nghiệp vụ",
            "D": "Yêu cầu sự tùy chỉnh đặc thù cho từng quy trình nghiệp vụ"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 8,
        "question_content": "Sau khi phân tách quy trình kinh doanh thành các hành động chi tiết, những loại hành động nào không phù hợp cho các bước mô hình hóa dịch vụ REST tiếp theo và nên được loại bỏ?",
        "options": {
            "A": "Các hành động liên quan đến truy cập cơ sở dữ liệu",
            "B": "Các hành động yêu cầu sử dụng giao diện người dùng đồ họa",
            "C": "Các hành động liên quan đến bảo mật và mã hóa thông tin",
            "D": "Các hành động cần phải thực hiện bởi con người hoặc các hệ thống cũ không thể đóng gói thành dịch vụ"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 9,
        "question_content": "Khi xác định tài nguyên, lợi ích chính của việc xác định các tài nguyên đa mục đích (agnostic resources) là gì?",
        "options": {
            "A": "Để giảm thiểu chi phí triển khai của dịch vụ",
            "B": "Để tăng cường tính bảo mật cho hệ thống",
            "C": "Để đánh dấu các phần của doanh nghiệp có khả năng được chia sẻ và tái sử dụng nhiều hơn",
            "D": "Để giảm thiểu số lượng lỗi trong quy trình nghiệp vụ"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 10,
        "question_content": "Microservices thường sử dụng giao thức nào thay vì SOAP để đạt hiệu suất cao?",
        "options": {
            "A": "HTTP",
            "B": "REST",
            "C": "SMTP",
            "D": "FTP"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 11,
        "question_content": "Sử dụng thuộc tính nào trong cấu trúc ràng buộc WSDL để xác định định dạng tải trọng thông điệp SOAP?",
        "options": {
            "A": "WSDL và REST",
            "B": "Document và Literal",
            "C": "Style và Use",
            "D": "SOAP và XML"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 12,
        "question_content": "Thường thì mức độ chi tiết của dịch vụ được xác định khi nào?",
        "options": {
            "A": "Trong giai đoạn phân tích và mô hình hóa",
            "B": "Trong giai đoạn thiết kế hợp đồng dịch vụ",
            "C": "Trong giai đoạn kiểm tra hiệu năng",
            "D": "Trong giai đoạn triển khai dịch vụ"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 13,
        "question_content": "Which of the following is a primary reason for using asynchronous communication in microservices?",
        "options": {
            "A": "To reduce latency in request handling",
            "B": "To simplify service discovery",
            "C": "To decouple services for better scalability",
            "D": "To enforce strict request-response patterns"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 14,
        "question_content": "Why is idempotency important in asynchronous communication?",
        "options": {
            "A": "To increase bandwidth",
            "B": "To reduce latency",
            "C": "To ensure reliable retries",
            "D": "To optimize caching"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 15,
        "question_content": "What does the Domain Event pattern facilitate?",
        "options": {
            "A": "Immediate data consistency",
            "B": "Long-running transactions",
            "C": "Loose coupling between services",
            "D": "UI responsiveness"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 16,
        "question_content": "What is the role of a domain model in a microservice application?",
        "options": {
            "A": "To define UI layout",
            "B": "To enforce security policies",
            "C": "To implement business rules and logic",
            "D": "To manage static content"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 17,
        "question_content": "When should a team split a monolith into microservices?",
        "options": {
            "A": "When the monolith is fast",
            "B": "When modular boundaries are clear and aligned to business domains",
            "C": "When using a single tech stack",
            "D": "At the start of a project"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 18,
        "question_content": "How can a service publish domain events to other services?",
        "options": {
            "A": "By using a shared memory object",
            "B": "Through REST polling",
            "C": "Via event-driven messaging",
            "D": "Through FTP updates"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 19,
        "question_content": "Which method helps to control traffic flow during progressive delivery?",
        "options": {
            "A": "Webhooks",
            "B": "Feature flags",
            "C": "Service mesh",
            "D": "Sidecar pattern"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 20,
        "question_content": "How might you ensure zero downtime during deployment?",
        "options": {
            "A": "Manual script execution",
            "B": "Scaling down before deployment",
            "C": "Using load balancer to shift traffic",
            "D": "Stopping old version before new one starts"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 21,
        "question_content": "What challenge is commonly associated with event sourcing?",
        "options": {
            "A": "Fast writes to the database",
            "B": "Scaling read operations",
            "C": "Keeping events small in size",
            "D": "Rebuilding state after many events"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 22,
        "question_content": "Which of the following best describes an event store?",
        "options": {
            "A": "A database for REST services",
            "B": "A service that sends push notifications",
            "C": "A log of immutable events that represent state transitions",
            "D": "A cache for recent API responses"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 23,
        "question_content": "Which of the following is NOT typically a client of the FTGO application’s API?",
        "options": {
            "A": "Browser-based JavaScript",
            "B": "Mobile applications",
            "C": "Third-party partners",
            "D": "Hardware routers"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 24,
        "question_content": "How can a gateway handle varied client needs efficiently?",
        "options": {
            "A": "Through DNS switching",
            "B": "By rejecting requests not from mobile",
            "C": "Using backend for frontends or GraphQL",
            "D": "Using token refresh only"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 25,
        "question_content": "Which pattern is useful when a client needs to contact multiple services in one logical operation?",
        "options": {
            "A": "Service Mesh",
            "B": "API Gateway",
            "C": "Saga",
            "D": "Backend for Frontend"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 26,
        "question_content": "What is the main characteristic of synchronous communication between microservices?",
        "options": {
            "A": "Messages are queued before delivery",
            "B": "Requests are fire-and-forget",
            "C": "Client waits for immediate response",
            "D": "Data is transferred in batch"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 27,
        "question_content": "In a CQRS system, how should you resolve inconsistencies in the query model caused by event processing delays?",
        "options": {
            "A": "By retrying failed events and implementing compensating mechanisms",
            "B": "By switching to synchronous write-read",
            "C": "By ignoring the delays",
            "D": "By updating the read model manually"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 28,
        "question_content": "Which pattern separates write operations from read operations in a microservices design?",
        "options": {
            "A": "Repository Pattern",
            "B": "CQRS",
            "C": "Event Sourcing",
            "D": "Service Locator"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 29,
        "question_content": "You are designing a distributed order process, which pattern would allow you to manage failures gracefully?",
        "options": {
            "A": "Two-Phase Commit",
            "B": "Synchronous RPC",
            "C": "Saga with compensating transactions",
            "D": "Retry with timeout"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 30,
        "question_content": "What does ACID stand for in transaction management?",
        "options": {
            "A": "Atomicity, Consistency, Isolation, Durability",
            "B": "Automation, Compatibility, Integrity, Deployment",
            "C": "Access, Coordination, Integrity, Distribution",
            "D": "Atomicity, Centralization, Implementation, Durability"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 31,
        "question_content": "Dịch vụ dựa trên SOAP hỗ trợ định dạng dữ liệu nào?",
        "options": {
            "A": "CSV",
            "B": "JSON",
            "C": "YAML",
            "D": "XML"
        },
        "correct_answer": "D"
    },
    {
        "question_number": 32,
        "question_content": "Dịch vụ dựa trên SOAP hay REST nhanh hơn?",
        "options": {
            "A": "SOAP",
            "B": "REST",
            "C": "Tùy thuộc vào cách triển khai",
            "D": "SOAP và REST có cùng tốc độ"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 33,
        "question_content": "Cho đoạn mã nguồn:\n\r\r@Path(\"/products\")\npublic class ProductResource {\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getProducts() {\n        // Get all products from the database.\n        return Response.ok(products).build();\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_XML)\n    public Response createProduct(Product product) {\n        // Create a new product in the database.\n        return Response.ok().build();\n    }\n\n    @PUT\n    @Path(\"{id}\")\n    @Consumes(MediaType.MULTIPART_FORM_DATA)\n    public Response updateProduct(@PathParam(\"id\") long id, Product product) {\n        // Update the product with the given ID in the database.\n        return Response.ok().build();\n    }\n\n    @DELETE\n    @Path(\"{id}\")\n    public Response deleteProduct(@PathParam(\"id\") long id) {\n        // Delete the product with the given ID from the database.\n        return Response.ok().build();\n    }\n\n}\n \n\r\rHTTP Request nào sẽ được chuyển cho updateProduct () ?",
        "options": {
            "A": "Phương thức PUT, đường dẫn /products",
            "B": "Phương thức PUT, đường dẫn /products/15",
            "C": "Phương thức GET, đường dẫn /products/15",
            "D": "Phương thức GET, đường dẫn /products"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 34,
        "question_content": "Cho đoạn mã nguồn:\n\r\r@Path(\"/orders\")\npublic class OrderResource {\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getOrders() {\n        // Get all orders from the database.\n        return Response.ok(orders).build();\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response createOrder(Order order) {\n        // Create a new order in the database.\n        return Response.ok().build();\n    }\n\n    @PUT\n    @Path(\"{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    public Response updateOrder(@PathParam(\"id\") long id, Order order) {\n        // Update the order with the given ID in the database.\n        return Response.ok().build();\n    }\n\n    @DELETE\n    @Path(\"{id}\")\n    public Response deleteOrder(@PathParam(\"id\") long id) {\n        // Delete the order with the given ID from the database.\n        return Response.ok().build();\n    }\n\n}\n\r\rPhương thức HTTP nào được sử dụng cho getOrders() ?",
        "options": {
            "A": "GET",
            "B": "POST",
            "C": "PUT",
            "D": "DELETE"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 35,
        "question_content": "Cho đoạn mã nguồn:\n\r\r@Path(\"/products\")\npublic class ProductResource {\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getProducts() {\n        // Get all products from the database.\n        return Response.ok(products).build();\n    }\n\n    @POST\n    @Consumes(MediaType.APPLICATION_XML)\n    public Response createProduct(Product product) {\n        // Create a new product in the database.\n        return Response.ok().build();\n    }\n\n    @PUT\n    @Path(\"{id}\")\n    @Consumes(MediaType.MULTIPART_FORM_DATA)\n    public Response updateProduct(@PathParam(\"id\") long id, Product product) {\n        // Update the product with the given ID in the database.\n        return Response.ok().build();\n    }\n\n    @DELETE\n    @Path(\"{id}\")\n    public Response deleteProduct(@PathParam(\"id\") long id) {\n        // Delete the product with the given ID from the database.\n        return Response.ok().build();\n    }\n\n}\n \n\r\rPhương thức HTTP cho phương thức createProduct() là gì?",
        "options": {
            "A": "GET",
            "B": "POST",
            "C": "PUT",
            "D": "DELETE"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 36,
        "question_content": "Phần tử nào trong WSDL xác định các phương thức và thông tin về chúng?",
        "options": {
            "A": "binding",
            "B": "service",
            "C": "portType",
            "D": "port"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 37,
        "question_content": "SOAP fault là gì?",
        "options": {
            "A": "Là một đối tượng được sử dụng trong lập trình web",
            "B": "Là một kiểu dữ liệu được sử dụng trong SOAP để truyền thông tin",
            "C": "Là một thông báo lỗi được trả về bởi server khi xảy ra lỗi trong quá trình thực hiện",
            "D": "Là một phương thức được sử dụng trong RESTful API"
        },
        "correct_answer": "C"
    },
    {
        "question_number": 38,
        "question_content": "Cho định nghĩa WSDL: \n\r\r<wsdl:definitions xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\" xmlns:tns=\"http://www.example.com/onlinecharging\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" name=\"OnlineCharging\" targetNamespace=\"http://www.example.com/onlinecharging\">\n  <wsdl:types>\n    <xsd:schema elementFormDefault=\"qualified\" targetNamespace=\"http://www.example.com/onlinecharging\">\n      <xsd:element name=\"Customer\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"CustomerId\" type=\"xsd:string\" minOccurs=\"1\" />\n            <xsd:element name=\"CustomerName\" type=\"xsd:string\" minOccurs=\"1\" />\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"Charge\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"CustomerId\" type=\"xsd:string\" minOccurs=\"1\" />\n            <xsd:element name=\"Amount\" type=\"xsd:double\" minOccurs=\"1\" />\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"ChargeResult\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"Status\" type=\"xsd:string\" minOccurs=\"1\" />\n            <xsd:element name=\"Message\" type=\"xsd:string\" minOccurs=\"1\" />\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n    </xsd:schema>\n  </wsdl:types>\n  <wsdl:message name=\"ChargeRequest\">\n    <wsdl:part name=\"customer\" element=\"tns:Customer\" />\n    <wsdl:part name=\"charge\" element=\"tns:Charge\" />\n  </wsdl:message>\n  <wsdl:message name=\"ChargeResponse\">\n    <wsdl:part name=\"result\" element=\"tns:ChargeResult\" />\n  </wsdl:message>\n  <wsdl:portType name=\"OnlineChargingPortType\">\n    <wsdl:operation name=\"Charge\">\n      <wsdl:input message=\"tns:ChargeRequest\" />\n      <wsdl:output message=\"tns:ChargeResponse\" />\n    </wsdl:operation>\n  </wsdl:portType>\n  <wsdl:binding name=\"OnlineChargingBinding\" type=\"tns:OnlineChargingPortType\">\n    <soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\" />\n    <wsdl:operation name=\"Charge\">\n      <soap:operation soapAction=\"http://www.example.com/onlinecharging/Charge\" />\n      <wsdl:input>\n        <soap:body use=\"literal\" />\n      </wsdl:input>\n      <wsdl:output>\n        <soap:body use=\"literal\" />\n      </wsdl:output>\n    </wsdl:operation>\n  </wsdl:binding>\n  <wsdl:service name=\"OnlineChargingService\">\n    <wsdl:port name=\"OnlineChargingPort\" binding=\"tns:OnlineChargingBinding\">\n      <soap:address location=\"http://www.example.com/onlinecharging\" />\n    </wsdl:port>\n  </wsdl:service>\n</wsdl:definitions> \n\r\rThông tin nào được dịch vụ web trả về?",
        "options": {
            "A": "Thông báo mô tả trạng thái của giao dịch nạp tiền",
            "B": "Trạng thái của giao dịch nạp tiền và thông điệp kèm theo",
            "C": "Mã khách hàng và số tiền đã nạp",
            "D": "Mã khách hàng, tên khách hàng, số tiền đã nạp và số thẻ tín dụng"
        },
        "correct_answer": "B"
    },
    {
        "question_number": 39,
        "question_content": "Cho định nghĩa WSDL: \n\r\r<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<definitions xmlns=\"http://schemas.xmlsoap.org/wsdl/\" xmlns:tns=\"http://www.example.com/accountRegistration\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" name=\"AccountRegistration\" targetNamespace=\"http://www.example.com/accountRegistration\">\n  <types>\n    <xsd:schema elementFormDefault=\"qualified\" targetNamespace=\"http://www.example.com/accountRegistration\">\n      <xsd:element name=\"Account\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"username\" type=\"xsd:string\"/>\n            <xsd:element name=\"password\" type=\"xsd:string\"/>\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"AccountResponse\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"success\" type=\"xsd:boolean\"/>\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n    </xsd:schema>\n  </types>\n  <message name=\"RegisterAccount\">\n    <part name=\"parameters\" element=\"tns:Account\"/>\n  </message>\n  <message name=\"RegisterAccountResponse\">\n    <part name=\"parameters\" element=\"tns:AccountResponse\"/>\n  </message>\n  <portType name=\"AccountRegistrationPortType\">\n    <operation name=\"RegisterAccount\">\n      <input message=\"tns:RegisterAccount\"/>\n      <output message=\"tns:RegisterAccountResponse\"/>\n    </operation>\n  </portType>\n  <binding name=\"AccountRegistrationBinding\" type=\"tns:AccountRegistrationPortType\">\n    <soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n    <operation name=\"RegisterAccount\">\n      <soap:operation soapAction=\"http://www.example.com/accountRegistration/RegisterAccount\"/>\n      <input>\n        <soap:body use=\"literal\"/>\n      </input>\n      <output>\n        <soap:body use=\"literal\"/>\n      </output>\n    </operation>\n  </binding>\n  <service name=\"AccountRegistrationService\">\n    <port name=\"AccountRegistrationPort\" binding=\"tns:AccountRegistrationBinding\">\n      <soap:address location=\"http://www.example.com/accountRegistration\"/>\n    </port>\n  </service>\n</definitions> \n\r\rDịch vụ web tên gì?",
        "options": {
            "A": "AccountRegistrationService",
            "B": "AccountRegistration",
            "C": "AccountRegistrationPortType",
            "D": "AccountRegistrationBinding"
        },
        "correct_answer": "A"
    },
    {
        "question_number": 40,
        "question_content": "Cho định nghĩa WSDL: \n\r\r<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<definitions xmlns=\"http://schemas.xmlsoap.org/wsdl/\" xmlns:tns=\"http://www.example.com/accountRegistration\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\" name=\"AccountRegistration\" targetNamespace=\"http://www.example.com/accountRegistration\">\n  <types>\n    <xsd:schema elementFormDefault=\"qualified\" targetNamespace=\"http://www.example.com/accountRegistration\">\n      <xsd:element name=\"Account\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"username\" type=\"xsd:string\"/>\n            <xsd:element name=\"password\" type=\"xsd:string\"/>\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"AccountResponse\">\n        <xsd:complexType>\n          <xsd:sequence>\n            <xsd:element name=\"success\" type=\"xsd:boolean\"/>\n          </xsd:sequence>\n        </xsd:complexType>\n      </xsd:element>\n    </xsd:schema>\n  </types>\n  <message name=\"RegisterAccount\">\n    <part name=\"parameters\" element=\"tns:Account\"/>\n  </message>\n  <message name=\"RegisterAccountResponse\">\n    <part name=\"parameters\" element=\"tns:AccountResponse\"/>\n  </message>\n  <portType name=\"AccountRegistrationPortType\">\n    <operation name=\"RegisterAccount\">\n      <input message=\"tns:RegisterAccount\"/>\n      <output message=\"tns:RegisterAccountResponse\"/>\n    </operation>\n  </portType>\n  <binding name=\"AccountRegistrationBinding\" type=\"tns:AccountRegistrationPortType\">\n    <soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n    <operation name=\"RegisterAccount\">\n      <soap:operation soapAction=\"http://www.example.com/accountRegistration/RegisterAccount\"/>\n      <input>\n        <soap:body use=\"literal\"/>\n      </input>\n      <output>\n        <soap:body use=\"literal\"/>\n      </output>\n    </operation>\n  </binding>\n  <service name=\"AccountRegistrationService\">\n    <port name=\"AccountRegistrationPort\" binding=\"tns:AccountRegistrationBinding\">\n      <soap:address location=\"http://www.example.com/accountRegistration\"/>\n    </port>\n  </service>\n</definitions> \n\r\rThông tin nào được dịch vụ web trả về?",
        "options": {
            "A": "Tên người dùng",
            "B": "Mật khẩu",
            "C": "Thành công hay không",
            "D": "Tên người dùng và mật khẩu"
        },
        "correct_answer": "C"
    }
]